<?xml version='1.0'?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?rfc toc="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<?rfc linkmailto="no" ?>
<?rfc editing="no" ?>
<?rfc comments="yes" ?>
<?rfc inline="yes"?>
<?rfc rfcedstyle="yes"?>
<?rfc-ext allow-markup-in-artwork="yes" ?>
<?rfc-ext include-index="no" ?>
<!--<?rfc strict="no"?> -->

<rfc category="info"
     ipr="trust200902"
     docName="draft-ietf-netmod-artwork-folding-latest">
    <front>
      <title abbrev="Handling Long Lines in Content">Handling Long Lines in Content of Internet-Drafts and RFCs</title>
        <author initials="K." surname="Watsen" fullname="Kent Watsen">
            <organization>Watsen Networks</organization>
            <address>
                <email>kent+ietf@watsen.net</email>
            </address>
        </author>
        <author initials="E." surname="Auerswald" fullname="Erik Auerswald">
            <organization>Individual Contributor</organization>
            <address>
                <email>auerswal@unix-ag.uni-kl.de</email>
            </address>
        </author>
        <author initials="A." surname="Farrel" fullname="Adrian Farrel" >
            <organization>Old Dog Consulting</organization>
            <address>
                <email>adrian@olddog.co.uk</email>
            </address>
        </author>
        <author initials="Q." surname="Wu" fullname="Qin Wu">
            <organization>Huawei Technologies</organization>
            <address>
                <email>bill.wu@huawei.com</email>
            </address>
        </author>
        <date/>
        <area>Operations</area>
        <workgroup>NETMOD Working Group</workgroup>
        <keyword>sourcecode</keyword>
        <keyword>artwork</keyword>
        <abstract>
          <t>This document defines two strategies for handling long lines in width-bounded
          text content.  One strategy, called the "single backslash" strategy,
          is based on the historical use of a single backslash
          ('\') character to indicate where line-folding has occurred, with the continuation
          occurring with the first character that is not a space character (' ') on the next line.  The second
          strategy, called the "double backslash" strategy,
          extends the first strategy by adding a second backslash character to
          identify where the continuation begins and is thereby able to handle cases not
          supported by the first strategy.  Both strategies use a self-describing header
          enabling automated reconstitution of the original content.</t>
        </abstract>
        <note title="Editorial Note (To be removed by RFC Editor)">
          <t>Please be aware that this document uses throughout the five-character text
            sequence located between the following two double-quotes: "(' ')".  It has been
            observed that some renderings of this text sequence produces a natural
            line break at the space character in the middle, thus causing "('" to appear
            at the end of the first line and "')" to appear at the beginning of the next
            line.  Such a line-break is confusing and should not occur in the RFC output
            formats.</t>
        </note>
    </front>

    <middle>
      <section title="Introduction">
        <t><xref target="RFC7994"/> sets out the requirements for
        plain-text RFCs and states that each line of an RFC (and hence of
        an Internet-Draft) must be limited to 72 characters followed by
        the character sequence that denotes an end-of-line (EOL).</t>

        <t>Internet-Drafts and RFCs often include example text or code
        fragments.  Many times the example text or code
        exceeds the 72 character line-length limit.  The 'xml2rfc' <xref target="xml2rfc"/>
        utility, at the time of this document's publication, does not
        attempt to wrap the content of such inclusions, simply issuing
        a warning whenever lines exceed 69 characters.  Historically,
        there has been no RFC-Editor-recommended convention in place
        for how to handle long lines in such inclusions, other than advising
        authors to clearly indicate what manipulation has occurred.</t>

      <t>This document defines two strategies for handling long lines in width-bounded
        text content.  One strategy is based on the historical use of a single backslash
        ('\') character to indicate where line-folding has occurred, with the continuation
        occurring with the first first character that is not a space (' ') character on the next line.  The second
        strategy extends the first strategy by adding a second backslash character to
        identify where the continuation begins and is thereby able to handle cases not
        supported by the first strategy.  Both strategies use a self-describing header
        enabling automated reconstitution of the original content.</t>

      <t>The strategies defined in this document work on any text content, but are
        primarily intended for a structured sequence of lines, such as would be
        referenced by the &lt;sourcecode&gt; element defined in Section 2.48 of
        <xref target="RFC7991"/>, rather than for two-dimensional imagery, such
        as would be referenced by the &lt;artwork&gt; element defined in Section
        2.5 of <xref target="RFC7991"/>.</t>

        <t>Note that text files are represented as lines having their first
        character in column 1, and a line length of N where the last
        character is in the Nth column and is immediately followed by an
        end-of-line character sequence.</t>
      </section>

      <section title="Applicability Statement">
        <t>The formats and algorithms defined in this document may be used
          in any context, whether for IETF documents or in other situations
          where structured folding is desired.</t>
        <t>Within the IETF, this work primarily targets the xml2rfc v3
          &lt;sourcecode&gt; element (Section 2.48 of <xref target="RFC7991"/>)
          and the xml2rfc v2 &lt;artwork&gt; element (Section 2.5 of
          <xref target="RFC7749"/>) that, for lack of a better option, is
          used in xml2rfc v2 for both source code and artwork.  This work may
          also be used for the xml2rfc v3 &lt;artwork&gt; element
          (Section 2.5 of <xref target="RFC7991"/>) but, as described in
          <xref target="not-for-art"/>, it is generally not recommended.</t>
      </section>

      <section title="Requirements Language" anchor="requirements-language">
        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
        NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
        "MAY", and "OPTIONAL" in this document are to be interpreted as
        described in BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/>
        when, and only when, they appear in all capitals, as shown here.</t>
      </section>

      <section title="Goals">
        <section title="Automated Folding of Long Lines in Text Content">
          <t>Automated folding of long lines is needed in order to support
            drafts that are dynamically compiled to include content with
            potentially unconstrained line lengths.  For instance, the
            build process may wish to include content from other local
            files or dynamically generated by some external process.
            Both of these cases are discussed next.</t>
          <t>Many drafts need to include the content from local files (e.g.,
            XML, JSON, ABNF, ASN.1).  Prior to including a file's content,
            the build process SHOULD first validate these source files
            using format-specific validators.  In order for such tooling
            to be able to process the files, the files must be in their
            original/natural state, which may entail them having some long
            lines.  Thus, these source files need to be folded before
            inclusion into the XML document, in order to satisfy 'xml2rfc'
            line-length limits.</t>
          <t>Similarly, drafts sometimes contain dynamically generated
            output, typically from an external process operating on the
            same source files discussed in the previous paragraph.  For
            instance, such processes may translate the input format to
            another format, or they may render a report on, or a view of, the input
            file.  In some cases, the dynamically generated output may
            contain lines exceeding the 'xml2rfc' line-length limits.</t>
          <t>In both cases, folding is required and SHOULD be automated 
            to reduce effort and errors resulting from manual processing.</t>
        </section>
        <section title="Automated Reconstitution of the Original Text Content">
          <t>Automated reconstitution of the exact original text content is needed to
            support validation of text-based content extracted from documents.</t>
          <t>For instance, already YANG <xref target="RFC7950"/> modules are
            extracted from Internet-Drafts and validated as part of the
            draft-submission process.  Additionally, the desire to validate
            instance examples (i.e., XML/JSON documents) contained within
            Internet-Drafts has been discussed (<xref target="yang-doctors-thread"/>).</t>
        </section>
      </section>

      <section title="Limitations">
        <section title="Not Recommended for Graphical Artwork" anchor="not-for-art">
          <t>While the solution presented in this document works on any
          kind of text-based content, it is most useful on content that
          represents source code (XML, JSON, etc.) or, more generally, on
          content that has not been laid out in two dimensions (e.g., diagrams).</t>
          <t>Fundamentally, the issue is whether the text content remains readable
          once folded.  Text content that is unpredictable is especially susceptible
          to looking bad when folded; falling into this category are most
          UML diagrams, YANG tree diagrams, and ASCII art in general.</t>
          <t>It is NOT RECOMMENDED to use the solution presented in
          this document on graphical artwork.</t>
        </section>
        <section title="Doesn't Work as Well as Format-Specific Options">
          <t>The solution presented in this document works generically
          for all text-based content, as it only views content as plain
          text.  However, various formats sometimes have built-in mechanisms
          that are better suited to prevent long lines.</t>
          <t>For instance, both the 'pyang' <xref target="pyang"/> and 'yanglint' <xref target="yanglint"/> utilities
          have the command line option "tree-line-length" that can
          be used to indicate a desired maximum line length for when
          generating tree diagrams <xref target="RFC8340"/>.</t>
          <t>In another example, some source formats (e.g., YANG
          <xref target="RFC7950"/>) allow any quoted string to be
          broken up into substrings separated by a concatenation
          character (e.g., '+'), any of which can be on a different
          line.</t>
          <t>It is RECOMMENDED that authors do as much as possible
          within the selected format to avoid long lines.</t>
        </section>
      </section>

      <section title="Two Folding Strategies" anchor="two-strategies">
        <t>This document defines two nearly identical strategies for folding
          text-based content.
          <list style="hanging" hangIndent="6">
            <t hangText="   The Single Backslash Strategy ('\'):">Uses a backslash
              ('\') character at the end of the line where folding occurs, and
              assumes that the continuation begins at the first character that is not
              a space (' ') character on the following line.</t>
            <t hangText="   The Double Backslash Strategy ('\\'):">Uses a backslash
              ('\') character at the end of the line where folding occurs, and
              assumes that the continuation begins after a second backslash ('\')
              character on the following line.</t>
          </list>
        </t>
        <section title="Comparison">
          <t>The first strategy produces more readable output, however it is
            significantly more likely to encounter unfoldable input (e.g.,
            a long line containing only space characters) and, for long lines
            that can be folded, automation implementations may encounter
            scenarios that will produce errors without special care.</t>
          <t>The second strategy produces less readable output, but is
            unlikely to encounter unfoldable input, there are no long lines
            that cannot be folded, and no special care is required for when
            folding a long line.</t>
        </section>
        <section title="Recommendation">
          <t>It is RECOMMENDED for implementations to first attempt to fold
            content using the single backslash strategy and, only in the
            unlikely event that it cannot fold the input or the folding
            logic is unable to cope with a contingency occurring on the
            desired folding column, then fallback to the double backslash
            strategy.</t>
        </section>
      </section>
          
      <section title="The Single Backslash Strategy ('\')" anchor="single-slash">
        <section title="Folded Structure">
          <t>Text content that has been folded as specified by this strategy
           MUST adhere to the following structure.</t>
          <section title="Header" anchor="single-header">
            <t>The header is two lines long.</t>
            <t>The first line is the following 36-character string that
            MAY be surrounded by any number of printable characters.
            This first line cannot itself be folded.
              <figure>
                <artwork><![CDATA[
NOTE: '\' line wrapping per RFC 8792
]]></artwork>
              </figure>
            </t>
            <t>The second line is an empty line, containing only the end-of-line
              character sequence.  This line provides visual separation for
              readability.</t>
          </section>
          <section title="Body">
            <t>The character encoding is the same as described in Section 2
            of <xref target="RFC7994"/>, except that, per <xref target="RFC7991"/>,
            tab characters are prohibited.</t>
            <t>Lines that have a backslash ('\') occurring as the last character in
            a line are considered "folded".</t>
            <t>Exceptionally long lines may be folded multiple times.</t>
          </section>
        </section>
  
        <section title="Algorithm" anchor="single-algorithm">
          <t>This section describes a process for folding and unfolding long
            lines when they are encountered in text content.</t>
          <t>The steps are complete, but implementations MAY achieve the same
            result in other ways.</t>
          <t>When a larger document contains multiple instances of text content
            that may need to be folded or unfolded, another process must
            insert/extract the individual text content instances to/from the
            larger document prior to utilizing the algorithms described in this
            section.  For example, the 'xiax' utility <xref target="xiax"/> does this.</t>
          <section title="Folding" anchor="single-folding">
            <t>Determine the desired maximum line length from input to the
            line-wrapping process, such as from a command line
            parameter.  If no value is explicitly specified, the value "69"
            SHOULD be used.</t>
            <t>Ensure that the desired maximum line length is not less than
            the minimum header, which is 36 characters.  If the desired
            maximum line length is less than this minimum, exit (this text-based
            content cannot be folded).</t>
            <t>Scan the text content for horizontal tab characters.  If any
            horizontal tab characters appear, either resolve them to space
            characters or exit, forcing the input provider to convert them
            to space characters themselves first.</t>
            <t>Scan the text content to ensure at least one line exceeds the
            desired maximum.  If no line exceeds the desired maximum, exit
            (this text content does not
            need to be folded).</t>
            <t>Scan the text content to ensure no existing lines already end with a
            backslash ('\') character, as this could lead to an ambiguous result.
            If such a line is found, and its width is less than the desired maximum,
            then it SHOULD be flagged for forced folding (folding even though
            unnecessary). If the folding implementation doesn't support forced
            foldings, it MUST exit.</t>
            <t>If this text content needs to and can be folded, insert the header
            described in <xref target="single-header" />, ensuring that any additional
            printable characters surrounding the header do not result in a
            line exceeding the desired maximum.</t>
            <t>For each line in the text content, from top-to-bottom, if the line
              exceeds the desired maximum, or requires a forced folding, then fold
              the line by:
              <list style="numbers">
                <t>Determine where the fold will occur.  This location MUST be before
                  or at the desired maximum column, and MUST NOT be chosen such that
                  the character immediately after the fold is a space (' ') character.
                  For forced foldings, the location is between the '\' and the
                  end-of-line character sequence.  If no such location can be
                  found, then exit (this text content cannot be folded).</t>
                <t>At the location where the fold is to occur, insert a backslash
                  ('\') character followed by the end-of-line character sequence.</t>
                <t>On the following line, insert any number of space (' ') characters,
                  provided that the resulting line does not exceed the desired maximum.</t>
              </list>
            </t>
            <t>The result of the previous operation is that the next line starts
            with an arbitrary number of space (' ') characters, followed by the
            character that was previously occupying the position where the fold
            occurred.</t>
            <t>Continue in this manner until reaching the end of the text content.  Note
            that this algorithm naturally addresses the case where the remainder
            of a folded line is still longer than the desired maximum, and hence
            needs to be folded again, ad infinitum.</t>
            <t>The process described in this section is illustrated by the "fold_it_1()"
            function in <xref target="script" />.</t>
          </section>
          <section title="Unfolding">
            <t>Scan the beginning of the text content for the header described in
              <xref target="single-header"/>.  If the header is not present, exit
              (this text content does not need to be unfolded).</t>
            <t>Remove the 2-line header from the text content.</t>
            <t>For each line in the text content, from top-to-bottom, if the line has
            a backslash ('\') character immediately followed by the end-of-line
            character sequence, then the line can be unfolded.
            Remove the backslash ('\') character, the end-of-line character
            sequence, and any leading space (' ') characters, which will bring up
            the next line.  Then continue to scan each line in the text content
            starting with the current line (in case it was multiply folded).</t>
            <t>Continue in this manner until reaching the end of the text content.</t>
            <t>The process described in this section is illustrated by the "unfold_it_1()"
            function in <xref target="script" />.</t>
          </section>
        </section>
      </section>

      <section title="The Double Backslash Strategy ('\\')" anchor="double-slash">

        <section title="Folded Structure">
          <t>Text content that has been folded as specified by this strategy
           MUST adhere to the following structure.</t>
          <section title="Header" anchor="double-header">
            <t>The header is two lines long.</t>
            <t>The first line is the following 37-character string that
            MAY be surrounded by any number of printable characters.
            This first line cannot itself be folded.
              <figure>
                <artwork><![CDATA[
NOTE: '\\' line wrapping per RFC 8792
]]></artwork>
              </figure>
            </t>
            <t>The second line is an empty line, containing only the end-of-line
              character sequence.  This line provides visual separation for
              readability.</t>
          </section>
          <section title="Body">
            <t>The character encoding is the same as described in Section 2
            of <xref target="RFC7994"/>, except that, per <xref target="RFC7991"/>,
            tab characters are prohibited.</t>
            <t>Lines that have a backslash ('\') occurring as the last character in
            a line immediately followed by the end-of-line character sequence, when
            the subsequent line starts with a backslash ('\') as the first first character that is not a space
            (' ') character, are considered "folded".</t>
            <t>Exceptionally long lines may be folded multiple times.</t>
          </section>
        </section>
  
        <section title="Algorithm" anchor="double-algorithm">
          <t>This section describes a process for folding and unfolding long
            lines when they are encountered in text content.</t>
          <t>The steps are complete, but implementations MAY achieve the same
            result in other ways.</t>
          <t>When a larger document contains multiple instances of text content
            that may need to be folded or unfolded, another process must
            insert/extract the individual text content instances to/from the
            larger document prior to utilizing the algorithms described in this
            section.  For example, the 'xiax' utility <xref target="xiax"/> does this.</t>
          <section title="Folding" anchor="double-folding">
            <t>Determine the desired maximum line length from input to the
            line-wrapping process, such as from a command line
            parameter.  If no value is explicitly specified, the value "69"
            SHOULD be used.</t>
            <t>Ensure that the desired maximum line length is not less than
            the minimum header, which is 37 characters.  If the desired
            maximum line length is less than this minimum, exit (this text-based
            content cannot be folded).</t>
            <t>Scan the text content for horizontal tab characters.  If any
            horizontal tab characters appear, either resolve them to space
            characters or exit, forcing the input provider to convert them
            to space characters themselves first.</t>
            <t>Scan the text content to see if any line exceeds the desired maximum.
            If no line exceeds the desired maximum, exit (this text content does not
            need to be folded).</t>
            <t>Scan the text content to ensure no existing lines already end with a
            backslash ('\') character while the subsequent line starts with a
            backslash ('\') character as the first first character that is not a space (' ') character,
            as this could lead to an ambiguous result.  If such a line is found,
            and its width is less than the desired maximum, then it SHOULD be
            flagged for forced folding (folding even though unnecessary).  If
            the folding implementation doesn't support forced foldings, it MUST
            exit.</t>
            <t>If this text content needs to and can be folded, insert the header
            described in <xref target="double-header" />, ensuring that any additional
            printable characters surrounding the header do not result in a
            line exceeding the desired maximum.</t>
            <t>For each line in the text content, from top-to-bottom, if the line
              exceeds the desired maximum, or requires a forced folding, then
              fold the line by:
              <list style="numbers">
                <t>Determine where the fold will occur.  This location MUST be before
                  or at the desired maximum column.  For forced foldings, the location
                  is between the '\' and the end-of-line character sequence on
                  the first line.</t>
                <t>At the location where the fold is to occur, insert a first
                  backslash ('\') character followed by the end-of-line character
                  sequence.</t>
                <t>On the following line, insert any number of space (' ') characters,
                  provided that the resulting line does not exceed the desired maximum,
                  followed by a second backslash ('\') character.</t>
              </list>
            </t>
            <t>The result of the previous operation is that the next line starts
            with an arbitrary number of space (' ') characters, followed by a
            backslash ('\') character, immediately followed by the character that
            was previously occupying the position where the fold occurred.</t>
            <t>Continue in this manner until reaching the end of the text content.  Note
            that this algorithm naturally addresses the case where the remainder
            of a folded line is still longer than the desired maximum, and hence
            needs to be folded again, ad infinitum.</t>
            <t>The process described in this section is illustrated by the "fold_it_2()"
            function in <xref target="script" />.</t>
          </section>
          <section title="Unfolding">
            <t>Scan the beginning of the text content for the header described in
              <xref target="double-header"/>.  If the header is not present, exit
              (this text content does not need to be unfolded).</t>
            <t>Remove the 2-line header from the text content.</t>
            <t>For each line in the text content, from top-to-bottom, if the line has
            a backslash ('\') character immediately followed by the end-of-line
            character sequence, and if the next line has a backslash ('\') character
            as the first first character that is not a space (' ') character, then the lines can be unfolded.
            Remove the first backslash ('\') character, the end-of-line character
            sequence, any leading space (' ') characters, and the second backslash
            ('\') character, which will bring up the next line.  Then continue to
            scan each line in the text content starting with the current line (in case
            it was multiply folded).</t>
            <t>Continue in this manner until reaching the end of the text content.</t>
            <t>The process described in this section is illustrated by the "unfold_it_2()"
            function in <xref target="script" />.</t>
          </section>
        </section>
      </section>

      <section anchor="example" title="Examples">
        <t>The following self-documenting examples illustrate folded
        text-based content.</t>

        <t>The source text content cannot be presented here, as it would
        again be folded. Alas, only the results can be provided.</t>

        <section title="Example Showing Boundary Conditions">
          <t>This example illustrates boundary conditions.  The input contains
            seven lines, each line one character longer than the previous line.
            Numbers for counting purposes.  The default desired maximum column
            value "69" is used.</t>
          <section title="Using '\'">
            <figure>
              <artwork><![CDATA[
INSERT_TEXT_FROM_FILE(refs/example-1.1.txt.folded)
]]></artwork>
            </figure>
          </section>
          <section title="Using '\\'">
            <figure>
              <artwork><![CDATA[
INSERT_TEXT_FROM_FILE(refs/example-1.2.txt.folded)
]]></artwork>
            </figure>
          </section>
        </section>

        <section title="Example Showing Multiple Wraps of a Single Line">
          <t>This example illustrates what happens when a very long line needs to
            be folded multiple times.  The input contains one line containing
            280 characters.  Numbers for counting purposes.  The default
            desired maximum column value "69" is used.</t>
          <section title="Using '\'">
            <figure>
              <artwork><![CDATA[
INSERT_TEXT_FROM_FILE(refs/example-2.1.txt.folded)
]]></artwork>
            </figure>
          </section>
          <section title="Using '\\'">
            <figure>
              <artwork><![CDATA[
INSERT_TEXT_FROM_FILE(refs/example-2.2.txt.folded)
]]></artwork>
            </figure>
          </section>
        </section>

        <section title="Example Showing &quot;Smart&quot; Folding">
          <t>This example illustrates how readability can be improved via "smart"
            folding, whereby folding occurs at format-specific locations and
            format-specific indentations are used.</t>
          <t>The text content was manually folded, since the script in the appendix
            does not implement smart folding.</t>
          <t>Note that the headers are surrounded by different printable characters
            than shown in the script-generated examples.</t>
          <section title="Using '\'">
            <figure>
              <artwork><![CDATA[
INSERT_TEXT_FROM_FILE(refs/example-3.1.txt.folded.smart)
]]></artwork>
            </figure>
            <t>Below is the equivalent to the above, but it was folded using the
              script in the appendix.</t>
            <figure>
              <artwork><![CDATA[
INSERT_TEXT_FROM_FILE(refs/example-3.1.txt.folded.smart.unfolded)
]]></artwork>
            </figure>
          </section>
          <section title="Using '\\'">
            <figure>
              <artwork><![CDATA[
INSERT_TEXT_FROM_FILE(refs/example-3.2.txt.folded.smart)
]]></artwork>
            </figure>
            <t>Below is the equivalent to the above, but it was folded using the
              script in the appendix.</t>
            <figure>
              <artwork><![CDATA[
INSERT_TEXT_FROM_FILE(refs/example-3.2.txt.folded.smart.unfolded.folded)
]]></artwork>
            </figure>
          </section>
        </section>

        <section title="Example Showing &quot;Forced&quot; Folding">
          <t>This example illustrates how invalid sequences in lines that do not
            have to be folded can be handled via forced folding, whereby the folding
            occurs even though unnecessary.</t>
          <t>
          <figure>
            <artwork><![CDATA[
INSERT_TEXT_FROM_FILE(refs/example-4.txt)
]]></artwork>
          </figure>
          </t>
          <t>The samples below were manually folded, since the script in the appendix
            does not implement forced folding.</t>
          <t>Note that the headers are prefixed by a pound ('#') character, rather 
            than surrounded by equal ('=') characters as shown in the script-generated
            examples.</t>
          <section title="Using '\'">
            <figure>
              <artwork><![CDATA[
INSERT_TEXT_FROM_FILE(refs/example-4.1.txt.folded.forced)
]]></artwork>
            </figure>
          </section>
          <section title="Using '\\'">
            <figure>
              <artwork><![CDATA[
INSERT_TEXT_FROM_FILE(refs/example-4.2.txt.folded.forced)
]]></artwork>
            </figure>
          </section>
        </section>
      </section>

      <section title="Security Considerations" anchor="sec-cons">
        <t>This RFC has no Security Considerations.</t>
      </section>

      <section title="IANA Considerations" anchor="iana-cons">
        <t>This RFC has no IANA Considerations.</t>
      </section>

    </middle>

    <back>

      <references title="Normative References">
        <?rfc include="reference.RFC.2119.xml"?>
        <?rfc include="reference.RFC.7991.xml"?>
        <?rfc include="reference.RFC.8174.xml"?>
      </references>

      <references title="Informative References">
        <?rfc include="reference.RFC.7950.xml"?>
        <?rfc include="reference.RFC.7749.xml"?>
        <?rfc include="reference.RFC.7994.xml"?>
        <?rfc include="reference.RFC.8340.xml"?>
        <reference anchor="yang-doctors-thread" target="https://mailarchive.ietf.org/arch/msg/yang-doctors/DCfBqgfZPAD7afzeDFlQ1Xm2X3g">
          <front>
            <title>[yang-doctors] automating yang doctor reviews</title>
            <author/>
            <date/>
          </front>
        </reference>
        <reference anchor="bash" target="https://www.gnu.org/software/bash/manual">
          <front><title>GNU Bash Manual</title><author/><date/></front>
        </reference>
        <reference anchor="xiax" target="https://pypi.org/project/xiax/">
          <front><title>The 'xiax' Python Package</title><author/><date/></front>
        </reference>
        <reference anchor="pyang" target="https://pypi.org/project/pyang/">
          <front><title>An extensible YANG (RFC 6020/7950) validator.</title><author/><date/></front>
        </reference>
        <reference anchor="xml2rfc" target="https://pypi.org/project/xml2rfc/">
          <front><title>Xml2rfc generates RFCs and IETF drafts from document source in XML according to the IETF xml2rfc v2 and v3 vocabularies.</title><author/><date/></front>
        </reference>
        <reference anchor="yanglint" target="https://github.com/CESNET/libyang#yanglint">
          <front><title>A feature-rich tool for validation and conversion of the schemas and YANG modeled data.</title><author/><date/></front>
        </reference>
      </references>


      <!-- APPENDICIES -->
      <section title="Bash Shell Script: rfcfold" anchor="script">
        <t>This non-normative appendix section includes a Bash <xref target="bash"/> shell script
          that can both fold and unfold text content using both the
          single and double backslash strategies described in
          <xref target="single-slash"/> and <xref target="double-slash"/>
          respectively.</t>
        <t>This script is intended to be applied to a single text content
          instance.  If it is desired to fold or unfold text content instances
          within a larger document (e.g., an Internet draft or RFC), then
          another tool must be used to extract the content from the larger
          document before utilizing this script.</t>
        <t>For readability purposes, this script forces the minimum
          supported line length to be eight characters longer than the
          raw header text defined in <xref target="single-header"/> and
          <xref target="double-header"/> so as to ensure that the header
          can be wrapped by a space (' ') character and three equal ('=')
          characters on each side of the raw header text.</t>
        <t>When a tab character is detected in the input file, this script
          exits with the error message:</t>
        <t>
          <figure>
            <artwork><![CDATA[
    Error: infile contains a tab character, which is not allowed.
]]></artwork>
          </figure>
        </t>
        <t>This script tests for the availability of GNU awk (gawk), in
          order to test for ASCII-based control characters and non-ASCII
          characters in the input file (see below).  Note that testing
          revealed flaws in the default version of 'awk' on some platforms.
          As this script uses 'gawk' only to issue warning messages,
          if 'gawk' is not found, this script issues the following debug
          message:
        </t>
        <t>
          <figure>
            <artwork><![CDATA[
    Debug: no GNU awk; skipping checks for special characters.
]]></artwork>
          </figure>
        </t>
        <t>When 'gawk' is available (see above) and ASCII-based control
          characters are detected in the input file, this script issues
          the warning message:</t>
        <t>
          <figure>
            <artwork><![CDATA[
    Warning: infile contains ASCII control characters (unsupported).
]]></artwork>
          </figure>
        </t>
        <t>When 'gawk' is available (see above) and non-ASCII characters
          are detected in the input file, this script issues the warning
          message:</t>
        <t>
          <figure>
            <artwork><![CDATA[
    Warning: infile contains non-ASCII characters (unsupported).
]]></artwork>
          </figure>
        </t>
        <t>This script does not implement the whitespace-avoidance logic
          described in <xref target="single-folding"/>.  In such case,
          the script will exit with the following message:</t>
        <t>
          <figure>
            <artwork><![CDATA[
    Error: infile has a space character occurring on the
    folding column. This file cannot be folded using the
    '\' strategy.
]]></artwork>
          </figure>
        </t>
        <t>While this script can unfold input that contains forced foldings,
          it is unable to fold files that would require forced foldings.  Forced
          folding is described in <xref target="single-folding"/> and
          <xref target="double-folding"/>.  When being asked to fold a file
          that would require forced folding, the script will instead exit
          with the following message:</t>
        <t>
          <figure>
            <preamble>For '\':</preamble>
            <artwork><![CDATA[
    Error: infile has a line ending with a '\' character.
    This file cannot be folded using the '\' strategy without
    there being false positives produced in the unfolding
    (i.e., this script does not force-fold such lines, as
    described in RFC 8792).
]]></artwork>
          </figure>
        </t>
        <t>
          <figure>
            <preamble>For '\\':</preamble>
            <artwork><![CDATA[
    Error: infile has a line ending with a '\' character
    followed by a '\' character as the first non-space
    character on the next line.  This script cannot fold
    this file using the '\\' strategy without there being
    false positives produced in the unfolding (i.e., this
    script does not force-fold such lines, as described
    in RFC 8792).
]]></artwork>
          </figure>
        </t>
        <t>Shell-level end-of-line backslash ('\') characters have been
          purposely added to the script so as to ensure that the script is
          itself not folded in this document, thus simplifying the ability to
          copy/paste the script for local use.  As should be evident by the
          lack of the mandatory header described in <xref target="single-header"/>,
          these backslashes do not designate a folded line, such as described
          in <xref target="single-slash"/>.</t>
        <t>
          <figure>
            <preamble>&lt;CODE BEGINS&gt;</preamble>
            <artwork name="rfcfold"><![CDATA[
INSERT_TEXT_FROM_FILE(rfcfold)
]]></artwork>
          <postamble>&lt;CODE ENDS&gt;</postamble>
          </figure>
        </t>
      </section>

      <section title="Acknowledgements" numbered="no">
        <t>The authors thank the RFC Editor for confirming that there was
          previously no set convention, at the time of this document's publication,
          for handling long lines in source code inclusions, thus instigating this
          work.</t>

        <t>The authors thank the following folks for their various
          contributions while producing this document (sorted by first name):
          Benoît Claise,
          Ben Kaduk,
          Gianmarco Bruno,
          Italo Busi,
          Joel Jaeggli,
          Jonathan Hansford,
          Lou Berger,
          Martin Bjorklund,
          and Rob Wilton.</t>

      </section>
    </back>

</rfc>
